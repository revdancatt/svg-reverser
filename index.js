#!/usr/bin/env node
/*
 * This script is used to reverse the paths in an SVG file.
 *
 * It only works for SVGs which are made up of lots of lines, so curves described by the SVG
 * won't work.
 *
 * I use this to reverse SVG files created with my own tools at revdancatt.com/penplotter
 * and to also reverse the output generated by the SVGSORT tool: https://github.com/inconvergent/svgsort
 *
 * If you have SVGSORT installed, then you can use an option parameter to make this script sort the
 * svg first before reversing it
 */

const fs = require('fs')
const path = require('path')
const colours = require('colors')
const commandLineArgs = require('command-line-args')

// Set up the colours we want to use for output
colours.setTheme({
  info: 'green',
  data: 'grey',
  help: 'cyan',
  warn: 'yellow',
  debug: 'blue',
  error: 'red',
  alert: 'magenta'
})

/*
 * Now we want to set up the command line args to catch them
 */
let showHelp = false
const argOptions = process.argv.slice(2)

//  See if we have asked for help
if (argOptions.includes('-h') || argOptions.includes('--help')) showHelp = true

//  See if we can grab a filename
const files = []
argOptions.forEach((arg) => {
  const argSplit = arg.split('.')
  const extension = argSplit.pop()
  if (extension === 'svg') files.push(arg)
})

//  If there are no files, or too many files, then we reject it all
if (files.length !== 1) showHelp = true

//  If we've been asked for help, or we need to show it, then show it and
//  move on
if (showHelp) {
  console.log(`
Usage: svg-reverser input.svg

Options:
 -s, --sort             Try and run the SVGSORT tool if installed

 -h, --help             Displays this help text
  `)
  process.exit()
}

//  Work out if we need to run a sort first
let runSort = false
if (argOptions.includes('-s') || argOptions.includes('--sort')) runSort = true

//  Now divide the file and the path
const filename = path.basename(files[0], '.svg')
const dir = path.resolve(path.dirname(files[0]))
const fullFile = path.join(dir, `${filename}.svg`)
//  Check that the file exist
if (!fs.existsSync(fullFile)) {
  console.log('Missing file: '.error, fullFile.warn)
  process.exit()
}

//  These are the files we are going to read in, and going to write out
const inputFile = path.join(dir, `${filename}.svg`)
const forwardFile = path.join(dir, `${filename}Forward.svg`)
const reversedFile = path.join(dir, `${filename}Reversed.svg`)
let isOptimised = false

//  Okay, now that we have gotten here we know we have an SVG file and that it exists
//  Now we want to know if we need to optimise it.
if (runSort) {
  //  We are going to attempt to optimise the file

  //  Run the SVGSORT script

  //  Update the inputFile

  //  Let us know we are isOptimised
  isOptimised = true
}

//  Now we read in the input file
const rawSVG = fs.readFileSync(inputFile, 'utf-8')

//  This is a bit messy but, instead of doing XML node based stuff I'm just going to treat the
//  XML like a string, and then do everything from there.
const head = rawSVG.split('<path')[0] // Grab everything before the first <path... node
let tail = rawSVG.split('/>') // Grab everything after the last
tail = tail.pop() // closing /> path node
const body = rawSVG.replace(head, '').replace(tail, '') // get the body by removing everything else

//  Now split down into the paths
const paths = body.split('<path d="').map((p) => {
  const pSplit = p.split('"')
  return pSplit[0]
})
paths.shift() // Remove the first element which will be empty

//  If we don't already know if we are optimised or not then we need to work that out here
if (!isOptimised) {
  //  How we work it out is to look at the first path, if it contains a comma then it is optimised
  //  if not, then it's just pumped out from our code and is in a slightly different format
  if (paths[0].indexOf(',') >= 0) isOptimised = true
}

//  Now we know if we are dealing with one format or the other, now we can build new lines
const newPaths = []
paths.forEach((path) => {
  //  Split the path, and then loop through
  const pathSplit = path.split(' ')
  let newPath = []
  while (pathSplit.length > 0) {
    let mode = 'M'
    let x = null
    let y = null
    mode = pathSplit.shift()
    if (!isOptimised) {
      x = pathSplit.shift()
      y = pathSplit.shift()
    } else {
      let xy = pathSplit.shift()
      xy = xy.split(',')
      x = xy[0]
      y = xy[1]
    }
    //  If the mode is 'M' then we are starting a new line, so close off the
    //  current one, and make a new one
    if (mode === 'M') {
      if (newPath.length) {
        newPaths.push(newPath)
        newPath = []
      }
    }
    if (x && y) {
      newPath.push({
        x,
        y
      })
    }
  }
  //  Put the last path into the stack
  if (newPath.length) newPaths.push(newPath)
})

const forwardPaths = JSON.parse(JSON.stringify(newPaths))
const reversePaths = JSON.parse(JSON.stringify(newPaths))

//  Now go thru the new paths reversing them
let forwardBody = ''
while (forwardPaths.length) {
  // Take off the last path
  const path = forwardPaths.shift()
  let newPath = ''
  while (path.length) {
    const xy = path.shift()
    if (newPath === '') {
      newPath = `M ${xy.x},${xy.y}`
    } else {
      newPath += ` L ${xy.x},${xy.y}`
    }
  }
  forwardBody += `<path d="${newPath}"  fill="none" stroke="black" stroke-width="1.0"/>
`
}

//  Now go thru the new paths reversing them
let reverseBody = ''
while (reversePaths.length) {
  // Take off the last path
  const path = reversePaths.pop()
  let newPath = ''
  while (path.length) {
    const xy = path.pop()
    if (newPath === '') {
      newPath = `M ${xy.x},${xy.y}`
    } else {
      newPath += ` L ${xy.x},${xy.y}`
    }
  }
  reverseBody += `<path d="${newPath}"  fill="none" stroke="black" stroke-width="1.0"/>
`
}

fs.writeFileSync(forwardFile, `${head}
${forwardBody}
${tail}`, 'utf-8')
fs.writeFileSync(reversedFile, `${head}
${reverseBody}
${tail}`, 'utf-8')
